---
title: "04-trait-diversity"
author: "Galina M. JÃ¶nsson"
date: "27/02/2020"
output: html_document
---


### Standardise functional traits

### Load functions and data
```{r clean-spp-names, eval=FALSE}
# Load trait data
traits <- read.csv("../data/cleanData/CleanTraitData.csv")

# Reclassify functional traits. Traits can be numeric, ordered, or factor. Binary traits should be numeric and only contain 0 and 1. character traits will be converted to factor. For a given trait, species with NA are excluded.
traits$species <- as.factor(traits$species)
traits$NEsp <- as.numeric(traits$NEsp) # Nectar specialisation: not based on any other traits used here
traits$Fsp <- as.numeric(traits$Fsp) # Adult feeding specialisation: not based on any other traits used here
traits$ProboscisL <- as.numeric(traits$ProboscisL) # Proboscis length
## Proboscis length more ecologically important than relative proboscis length so will remove
traits$RPL <- as.numeric(traits$RPL) # Relative proboscis length
##
traits$EggSize <- as.numeric(traits$EggSize) # Egg size
## Use egg size rather than relative egg size because it is just multiplied by the wingspand (included)
traits$RES <- as.numeric(traits$RES) # Relative egg size
##
traits$Symbiosis <- as.ordered(traits$Symbiosis) # Symbiosis in early stadia
traits$HibStage <- as.ordered(traits$HibStage) # Hibernation stage (1 to 4, 2.5 for P. aegeria)
## Below four traits are summarised in "HibStage" so should be removed
traits$HSegg <- as.numeric(traits$HSegg) # Hibernation stage (egg stage) 
traits$HSlarva <- as.numeric(traits$HSlarva) # Hibernation stage (larval stage)
traits$HSpupa <- as.numeric(traits$HSpupa) # Hibernation stage (pupal stage)
traits$HSadult <- as.numeric(traits$HSadult) # Hibernation stage (adult stage)
##
traits$POPSTR2 <- as.ordered(traits$POPSTR2) # Population structure
## "Overwintering.stage" is same as "HibStage" so should be removed
traits$Overwintering.stage <- as.ordered(traits$Overwintering.stage)
##
traits$Perching <- as.numeric(traits$Perching)
traits$Patrolling <- as.numeric(traits$Patrolling)
## "Mate.locating.strategy" is summary of "Perching" and "Patrolling" so should be removed
traits$Mate.locating.strategy <- as.factor(traits$Mate.locating.strategy)
##
traits$Wingspan.average <- as.numeric(traits$Wingspan.average)

#### Get rid of the traits outlined above
traits <-  traits[ , -which(names(traits) %in% c("RPL", # Relative proboscis length
                                                 "RES", # Relative egg size
                                                 "HSegg", # Hibernation stage (egg stage) 
                                                 "HSlarva", # Hibernation stage (larval stage)
                                                 "HSpupa", # Hibernation stage (pupal stage)
                                                 "HSadult", # Hibernation stage (adult stage)
                                                 "Overwintering.stage",
                                                 "Mate.locating.strategy"))]


# Rename Polygonia c-album in traits dataset to match the occu data
levels(traits$species)[levels(traits$species)=="Polygonia.c-album"] <- "Polygonia.c.album"

# Make the species column in trait the row names and get rid of the column
row.names(traits) <- traits$species
traits <- traits[,c(1:10)]
```


Once the species-species distance matrix is obtained, dbFD checks whether it is Euclidean. This
is done via is.euclid. PCoA axes corresponding to negative eigenvalues are imaginary axes that
cannot be represented in a Euclidean space, but simply ignoring these axes would lead to biased
estimations of FD. Hence in dbFD one of four correction methods are used, following argument
corr. "sqrt" simply takes the square root of the distances. However, this approach does not always
work for all coefficients, in which case dbFD will stop and tell the user to select another correction
method. "cailliez" refers to the approach described by Cailliez (1983) and is implemented via
cailliez. "lingoes" refers to the approach described by Lingoes (1971) and is implemented via
lingoes. "none" creates a distance matrix with only the positive eigenvalues of the Euclidean
representation via quasieuclid. See Legendre and Legendre (1998) and Legendre and Anderson
(1999) for more details on these corrections.
```{r setup, include=FALSE}
# Load the function that extracts a selected number of estimates from the posterior distribution
source("../analyses/function-extractPosterior.R")

# Use the function to extract the data
occu <- summarise_posterior('../outputs/2019_outputs/', iterations = 100, years = 110, verbose = TRUE)

# Create an empty list to populate with FD outputs for each iteration
FD_list = vector(mode = "list", length = 100)

# Loop through all occu matrices in occu (each representing an iteration) and fill FD_list
require(FD)
for(i in 1:100){
  FD_list[[i]] <- dbFD(traits, occu[[i]], 
                     w.abun = TRUE, calc.CWM = TRUE, 
                     corr="cailliez") # 'cailliez' correction because 'sqrt' does not work
}

# Name each list (i.e. iteration) "Iter" followed by number
nameList <- paste("Iter", 1:100, sep = "")
names(FD_list) <- nameList

# Save the file
#saveRDS(FD_list, "../outputs/FDoutputs/FDlist13March.rds")
```



### Summarise matrics
```{r summarise-visualise}
# Read the data
FD_list <- readRDS("../outputs/FDoutputs/FDlist13March.rds")

# Source a function that summarises the matrics list
source("../analyses/function-summarise_FDmatrics.R")

# Run the functrion
FDmatrics <- summarise_FDmatrics(FD_list, 100, 110)
```

### Make null model

```{r null-model}
require(vegan)

# Create an empty list to populate with null outputs for each iteration
null_occu = vector(mode = "list", length = 100)

require(FD)
# Loop through all occu matrices in occu (each representing an iteration) and fill null_list
for(i in 1:100){
  (nm <- nullmodel((occu[[i]]), "abuswap_r"))
  (null_occu[[i]] <- (simulate(nm, burnin=1000, nsim=1000, thin=1000))[,,1000])
}

# Create an empty list to populate with null FD outputs for each iteration
nullFD_list = vector(mode = "list", length = 100)

# Loop through all occu matrices in null_list (each representing an iteration) and fill nullFD_list
for(i in 1:100){
  nullFD_list[[i]] <- dbFD(traits, null_list[[i]], 
                     w.abun = TRUE, calc.CWM = TRUE, 
                     corr="cailliez") # 'cailliez' correction because 'sqrt' does not work
}

# Name each list (i.e. iteration) "Iter" followed by number
nameList <- paste("Iter", 1:100, sep = "")
names(nullFD_list) <- nameList

# Save the file
#saveRDS(nullFD_list, "../outputs/FDoutputs/nullFD_list19March.rds")
```

### Summarise null model metrics
```{r summarise-null-model}
# Read nullFD_list
nullFD_list <- readRDS("../outputs/FDoutputs/nullFD_list19March.rds")

# Source a function that summarises the matrics list
source("../analyses/function-summarise_FDmatrics.R")

# Run the functrion
nullFDmatrics <- summarise_FDmatrics(nullFD_list, 100, 110)


# Plot both functional evenness for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(nullFDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")


# Plot both functional divergence for both estimates from posterior samples and null samples
ggplot(FDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(nullFDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")
```





### Find Index of variance - Functional evenness

```{r FEve-IV}
FEveIV <- FDmatrics$FEveSum[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the standardised effect size
for(j in 1:110){
  for(i in 1:100){
    FEveIV[j,i] <- (2*((FDmatrics$FEveSum[j,i])/((nullFDmatrics$FEveSum[j,102])+(FDmatrics$FEveSum[j,i]))))-1
    }
}

require(plotrix)
FEveIV$mean <- apply(FEveIV[,1:100], 1, mean)
FEveIV$sd <- apply(FEveIV[,1:100], 1, sd)
FEveIV$sem <- apply(FEveIV[,1:100], 1, std.error)


# Plot both functional evenness for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(nullFDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(FEveIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Index of variance for functional evenness +- 1 SD") +
  xlab("Year") + ylab("Index of Variance (Functional evenness)")
```



### Index of variance - Functional divergence

```{r FDiv-IV}
FDivIV <- FDmatrics$FDivSum[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the Index of variance
for(j in 1:110){
  for(i in 1:100){
    FDivIV[j,i] <- (2*((FDmatrics$FDivSum[j,i])/((nullFDmatrics$FDivSum[j,102])+(FDmatrics$FDivSum[j,i]))))-1
    }
}

require(plotrix)
FDivIV$mean <- apply(FDivIV[,1:100], 1, mean)
FDivIV$sd <- apply(FDivIV[,1:100], 1, sd)
FDivIV$sem <- apply(FDivIV[,1:100], 1, std.error)



# Plot both functional divergence for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(nullFDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(FDivIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Index of variance for functional divergence +- 1 SD") +
  xlab("Year") + ylab("Index of variance (functional divergence)")

```

### Functional trait composition

```{r CWM-summary}
# Source a function that summarises the CWMs in the matrics list
source("../analyses/function-summarise_CWM.R")

########## Average Wingspan ##########

# Summarise absolute chnage in average wingspan
Wingspan.average <- summarise_CWM(FD_list, 10, 100,110)

# Summarise null change in average wingspan
NullWingspan.average <- summarise_CWM(nullFD_list, 10, 100,110)

Wingspan.averageIV <- Wingspan.average[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the Index of variance
for(j in 1:110){
  for(i in 1:100){
    Wingspan.averageIV[j,i] <- (2*((Wingspan.average[j,i])/((NullWingspan.average[j,102])+(Wingspan.average[j,i]))))-1
    }
}

require(plotrix)
Wingspan.averageIV$mean <- apply(Wingspan.averageIV[,1:100], 1, mean)
Wingspan.averageIV$sd <- apply(Wingspan.averageIV[,1:100], 1, sd)
Wingspan.averageIV$sem <- apply(Wingspan.averageIV[,1:100], 1, std.error)


# plot average wingspan
ggplot(Wingspan.average, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Wingspan.average +- 1 SD") +
  xlab("Year") + ylab("Wingspan.average (mm)")

# plot average wingspan
ggplot(NullWingspan.average, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null Wingspan.average +- 1 SD") +
  xlab("Year") + ylab("Wingspan.average (mm)")

# plot average wingspan
ggplot(Wingspan.averageIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Wingspan.average +- 1 SD") +
  xlab("Year") + ylab("Indext of Variance (Wingspan.average")





########## Egg size ##########

# Summarise absolute chnage in average wingspan
EggSize <- summarise_CWM(FD_list, 4, 100,110)

# Summarise null change in average wingspan
NullEggSize <- summarise_CWM(nullFD_list, 4, 100,110)

EggSizeIV <- EggSize[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the Index of variance
for(j in 1:110){
  for(i in 1:100){
    EggSizeIV[j,i] <- (2*((EggSize[j,i])/((NullEggSize[j,102])+(EggSize[j,i]))))-1
    }
}

require(plotrix)
EggSizeIV$mean <- apply(EggSizeIV[,1:100], 1, mean)
EggSizeIV$sd <- apply(EggSizeIV[,1:100], 1, sd)
EggSizeIV$sem <- apply(EggSizeIV[,1:100], 1, std.error)


# plot egg size
ggplot(EggSize, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Egg Size +- 1 SD") +
  xlab("Year") + ylab("Egg Size")

# plot average wingspan
ggplot(NullEggSize, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null Egg Size +- 1 SD") +
  xlab("Year") + ylab("Egg Size")

# plot average wingspan
ggplot(EggSizeIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("EggSize +- 1 SD") +
  xlab("Year") + ylab("Indext of Variance (Egg Size")


########## Proboscis Length ##########
ProboscisL <- summarise_CWM(FD_list, 3, 100,110)

ggplot(ProboscisL, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("ProboscisL +- 1 SD") +
  xlab("Year") + ylab("Proboscis Length")


########## Nectar specialisation ##########
NEsp <- summarise_CWM(FD_list, 1, 100,110)

ggplot(NEsp, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Nectar specialisation +- 1 SD") +
  xlab("Year") + ylab("Nectar specialisation")



########## Feeding specialisation ##########
Fsp <- summarise_CWM(FD_list, 2, 100,110)

ggplot(Fsp, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Feeding specialisation +- 1 SD") +
  xlab("Year") + ylab("Feeding specialisation")



########## Symbiosis ##########
Symbiosis <- summarise_CWM(FD_list, 5, 100,110)

# Loop through and make all columns numeric
for(i in 1:100){
  Symbiosis[,i] <- as.numeric(as.character(Symbiosis[,i]))
}

# summarise mean, sd and sem
require(plotrix)
Symbiosis$mean <- apply(Symbiosis[,1:100], 1, mean)
Symbiosis$sd <- apply(Symbiosis[,1:100], 1, sd)
Symbiosis$sem <- apply(Symbiosis[,1:100], 1, std.error)

# plot
ggplot(Symbiosis, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Symbiosis +- 1 SD") +
  xlab("Year") + ylab("Symbiosis")


########## Hibernation stage ##########
HibStage <- summarise_CWM(FD_list, 6, 100,110)

# Loop through and make all columns numeric
for(i in 1:100){
  HibStage[,i] <- as.numeric(as.character(HibStage[,i]))
}

# summarise mean, sd and sem
require(plotrix)
HibStage$mean <- apply(HibStage[,1:100], 1, mean)
HibStage$sd <- apply(HibStage[,1:100], 1, sd)
HibStage$sem <- apply(HibStage[,1:100], 1, std.error)

# plot
ggplot(HibStage, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("HibStage +- 1 SD") +
  xlab("Year") + ylab("HibStage")



########## Population Structure ##########
POPSTR2 <- summarise_CWM(FD_list, 7, 100,110)

# Loop through and make all columns numeric
for(i in 1:100){
  POPSTR2[,i] <- as.numeric(as.character(POPSTR2[,i]))
}

# summarise mean, sd and sem
require(plotrix)
POPSTR2$mean <- apply(POPSTR2[,1:100], 1, mean)
POPSTR2$sd <- apply(POPSTR2[,1:100], 1, sd)
POPSTR2$sem <- apply(POPSTR2[,1:100], 1, std.error)

# plot
ggplot(POPSTR2, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("POPSTR2 +- 1 SD") +
  xlab("Year") + ylab("POPSTR2")




########## Perching ##########
Perching <- summarise_CWM(FD_list, 8, 100,110)

# Loop through and make all columns numeric
for(i in 1:100){
  Perching[,i] <- as.numeric(as.character(Perching[,i]))
}

# summarise mean, sd and sem
require(plotrix)
Perching$mean <- apply(Perching[,1:100], 1, mean)
Perching$sd <- apply(Perching[,1:100], 1, sd)
Perching$sem <- apply(Perching[,1:100], 1, std.error)

# plot
ggplot(Perching, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Perching +- 1 SD") +
  xlab("Year") + ylab("Perching")





########## Patrolling ##########
Patrolling <- summarise_CWM(FD_list, 9, 100,110)

# Loop through and make all columns numeric
for(i in 1:100){
  Patrolling[,i] <- as.numeric(as.character(Patrolling[,i]))
}

# summarise mean, sd and sem
require(plotrix)
Patrolling$mean <- apply(Patrolling[,1:100], 1, mean)
Patrolling$sd <- apply(Patrolling[,1:100], 1, sd)
Patrolling$sem <- apply(Patrolling[,1:100], 1, std.error)

# plot
ggplot(Patrolling, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Patrolling +- 1 SD") +
  xlab("Year") + ylab("Patrolling")

```