---
title: "04-trait-diversity"
author: "Galina M. JÃ¶nsson"
date: "27/02/2020"
output: html_document
---


### Standardise functional traits

### Load functions and data
```{r clean-spp-names, eval=FALSE}
# Load trait data
traits <- read.csv("../data/cleanData/CleanTraitData.csv")

# Reclassify functional traits. Traits can be numeric, ordered, or factor. Binary traits should be numeric and only contain 0 and 1. character traits will be converted to factor. For a given trait, species with NA are excluded.
traits$species <- as.factor(traits$species)
traits$Fsp <- as.numeric(traits$Fsp) # Adult feeding specialisation: not based on any other traits used here
traits$ProboscisL <- as.numeric(traits$ProboscisL) # Proboscis length
traits$EggSize <- as.numeric(traits$EggSize) # Egg size
traits$Symbiosis <- as.ordered(traits$Symbiosis) # Symbiosis in early stadia
traits$Overwintering.stage <- as.ordered(traits$Overwintering.stage) # Hibernation stage (1 to 4)
traits$POPSTR1 <- as.ordered(traits$POPSTR1) # Population structure
traits$PopStr1t <- as.ordered(traits$PopStr1t) # Breeding population structure
traits$METApop <- as.ordered(traits$METApop) # Metapopulation structure
traits$VoltScore <- as.ordered(traits$VoltScore) 
traits$PhagyAll <- as.ordered(traits$PhagyAll) 
traits$AH <- as.ordered(traits$AH) 
traits$Wingspan.average <- as.numeric(traits$Wingspan.average)
traits$HPphenRange <- as.numeric(traits$HPphenRange)
traits$mobilityscore <- as.numeric(traits$mobilityscore)
traits$ELC <- as.numeric(traits$ELC)


# Rename Polygonia c-album in traits dataset to match the occu data
levels(traits$species)[levels(traits$species)=="Polygonia.c-album"] <- "Polygonia.c.album"

# Make the species column in trait the row names and get rid of the column
row.names(traits) <- traits$species
traits <- traits[,1:15]

traits <- traits[,c(15,1,9,10,6,3,2,4:5,8,14,7,11:13)]
```


Once the species-species distance matrix is obtained, dbFD checks whether it is Euclidean. This
is done via is.euclid. PCoA axes corresponding to negative eigenvalues are imaginary axes that
cannot be represented in a Euclidean space, but simply ignoring these axes would lead to biased
estimations of FD. Hence in dbFD one of four correction methods are used, following argument
corr. "sqrt" simply takes the square root of the distances. However, this approach does not always
work for all coefficients, in which case dbFD will stop and tell the user to select another correction
method. "cailliez" refers to the approach described by Cailliez (1983) and is implemented via
cailliez. "lingoes" refers to the approach described by Lingoes (1971) and is implemented via
lingoes. "none" creates a distance matrix with only the positive eigenvalues of the Euclidean
representation via quasieuclid. See Legendre and Legendre (1998) and Legendre and Anderson
(1999) for more details on these corrections.
```{r setup, include=FALSE}
# Load the function that extracts a selected number of estimates from the posterior distribution
source("../analyses/function-extractPosterior.R")

# Use the function to extract the data
occu <- summarise_posterior('../outputs/2019_outputs/', iterations = 1000, years = 110, verbose = TRUE)

#saveRDS(occu, "../outputs/FDoutputs/occu1000.rds")

# Create an empty list to populate with FD outputs for each iteration
FD_list = vector(mode = "list", length = 1000)

# Trait weights
w <- c(3,3,
       2,2,2,
       3,3,
       3,3,
       2,2,2,
       2,2,2)

# Loop through all occu matrices in occu (each representing an iteration) and fill FD_list
require(FD)
for(i in 1:1000){
  FD_list[[i]] <- dbFD(traits, occu[[i]], w,
                     w.abun = TRUE, calc.CWM = TRUE, 
                     corr="cailliez") # 'cailliez' correction because 'sqrt' does not work
}

# Name each list (i.e. iteration) "Iter" followed by number
nameList <- paste("Iter", 1:1000, sep = "")
names(FD_list) <- nameList

# Save the file
#saveRDS(FD_list, "../outputs/FDoutputs/FDlist13March.rds")
```



### Summarise matrics
```{r summarise-visualise}
# Read the data
FD_list <- readRDS("../outputs/FDoutputs/FD_list.rds")

# Source a function that summarises the matrics list
source("../analyses/function-summarise_FDmatrics.R")

# Run the functrion
FDmatrics <- summarise_FDmatrics(FD_list, 1000, 110)
```



### Make null model

```{r null-model}
require(vegan)

# Read original occu
occu <- readRDS("../outputs/FDoutputs/occu1000.rds")

# Create an empty list to populate with null outputs for each iteration
null_occu = vector(mode = "list", length = 1000)

require(FD)
# Loop through all occu matrices in occu (each representing an iteration) and fill null_list
for(i in 1:1000){
  (nm <- nullmodel((occu[[i]]), "abuswap_r"))
  (null_occu[[i]] <- (simulate(nm, burnin=1000, nsim=1000, thin=1000))[,,1000])
}

# Save
#saveRDS(null_occu, "../outputs/FDoutputs/null_occu1000.rds")

# Create an empty list to populate with null FD outputs for each iteration
nullFD_list = vector(mode = "list", length = 1000)

# Trait weights
w <- c(3,3,
       2,2,2,
       3,3,
       3,3,
       2,2,2,
       2,2,2)

# Loop through all occu matrices in null_list (each representing an iteration) and fill nullFD_list
for(i in 1:1000){
  nullFD_list[[i]] <- dbFD(traits, null_list[[i]], w,
                     w.abun = TRUE, calc.CWM = TRUE, 
                     corr="cailliez") # 'cailliez' correction because 'sqrt' does not work
}

# Name each list (i.e. iteration) "Iter" followed by number
nameList <- paste("Iter", 1:1000, sep = "")
names(nullFD_list) <- nameList

# Save the file
#saveRDS(nullFD_list, "../outputs/FDoutputs/null_FD_list.rds")
```

### Summarise null model metrics
```{r summarise-null-model}
# Read nullFD_list
nullFD_list <- readRDS("../outputs/FDoutputs/null_FD_list.rds")

# Source a function that summarises the matrics list
source("../analyses/function-summarise_FDmatrics.R")

# Run the functrion
nullFDmatrics <- summarise_FDmatrics(nullFD_list, 1000, 110)


# Plot both functional evenness for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(nullFDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")


# Plot both functional divergence for both estimates from posterior samples and null samples
ggplot(FDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(nullFDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")
```





### Find Index of variance - Functional evenness

```{r FEve-IV}
FEveIV <- FDmatrics$FEveSum[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the standardised effect size
for(j in 1:110){
  for(i in 1:100){
    FEveIV[j,i] <- (2*((FDmatrics$FEveSum[j,i])/((nullFDmatrics$FEveSum[j,102])+(FDmatrics$FEveSum[j,i]))))-1
    }
}

require(plotrix)
FEveIV$mean <- apply(FEveIV[,1:100], 1, mean)
FEveIV$sd <- apply(FEveIV[,1:100], 1, sd)
FEveIV$sem <- apply(FEveIV[,1:100], 1, std.error)


# Plot both functional evenness for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(nullFDmatrics$FEveSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional evenness +- 1 SD") +
  xlab("Year") + ylab("Functional evenness")

ggplot(FEveIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Index of variance for functional evenness +- 1 SD") +
  xlab("Year") + ylab("Index of Variance (Functional evenness)")
```



### Index of variance - Functional divergence

```{r FDiv-IV}
FDivIV <- FDmatrics$FDivSum[,1:101]

# Loop through all FEveSum iterations in FDmatrics and find the Index of variance
for(j in 1:110){
  for(i in 1:100){
    FDivIV[j,i] <- (2*((FDmatrics$FDivSum[j,i])/((nullFDmatrics$FDivSum[j,102])+(FDmatrics$FDivSum[j,i]))))-1
    }
}

require(plotrix)
FDivIV$mean <- apply(FDivIV[,1:100], 1, mean)
FDivIV$sd <- apply(FDivIV[,1:100], 1, sd)
FDivIV$sem <- apply(FDivIV[,1:100], 1, std.error)



# Plot both functional divergence for both estimates from posterior samples and null samples
require(ggplot2)
ggplot(FDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(nullFDmatrics$FDivSum, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Null functional divergence +- 1 SD") +
  xlab("Year") + ylab("Functional divergence")

ggplot(FDivIV, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Index of variance for functional divergence +- 1 SD") +
  xlab("Year") + ylab("Index of variance (functional divergence)")

```

### Functional trait composition

```{r CWM-summary}
# Source a function that summarises the CWMs in the matrics list
source("../analyses/function-summarise_CWM.R")


###########################################################
########################  MOBILITY  #######################
###########################################################

### Average Wingspan
# Summarise absolute chnage in average wingspan
Wingspan.average <- summarise_CWM(FD_list, 1, 1000,110)
# plot average wingspan
ggplot(Wingspan.average, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Wingspan") +
  xlab("Year") + ylab("Wingspan (mm)")


### Mobility Score
Mobility.score <- summarise_CWM(FD_list, 2, 1000,110)
# plot average wingspan
ggplot(Mobility.score, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Mobility Score") +
  xlab("Year") + ylab("Mobility Score")




###########################################################
#################  Laval dietary breadth  #################
###########################################################
### Phagy score
PhagyAll <- summarise_CWM(FD_list, 3, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  PhagyAll[,i] <- as.numeric(as.character(PhagyAll[,i]))
}
# summarise mean, sd and sem
require(plotrix)
PhagyAll$mean <- apply(PhagyAll[,1:1000], 1, mean)
PhagyAll$sd <- apply(PhagyAll[,1:1000], 1, sd)
PhagyAll$sem <- apply(PhagyAll[,1:1000], 1, std.error)
# plot
ggplot(PhagyAll, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Phagy score") +
  xlab("Year") + ylab("Phagy score")

### Number of host plants
HPphenRange <- summarise_CWM(FD_list, 4, 1000,110)
# plot
ggplot(HPphenRange, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Number of host plants") +
  xlab("Year") + ylab("Number of host plants")

### Symbiosis
Symbiosis <- summarise_CWM(FD_list, 5, 100,110)
# Loop through and make all columns numeric
for(i in 1:100){
  Symbiosis[,i] <- as.numeric(as.character(Symbiosis[,i]))
}
# summarise mean, sd and sem
require(plotrix)
Symbiosis$mean <- apply(Symbiosis[,1:100], 1, mean)
Symbiosis$sd <- apply(Symbiosis[,1:100], 1, sd)
Symbiosis$sem <- apply(Symbiosis[,1:100], 1, std.error)
# plot
ggplot(Symbiosis, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Symbiosis score") +
  xlab("Year") + ylab("Symbiosis score")




###########################################################
#################  Adult dietary breadth  #################
###########################################################

### Proboscis length
ProboscisL <- summarise_CWM(FD_list, 6, 1000,110)
# plot
ggplot(HPphenRange, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Proboscis length") +
  xlab("Year") + ylab("Proboscis length (mm)")


### Feeding specialisation
Fsp <- summarise_CWM(FD_list, 7, 1000,110)
ggplot(Fsp, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Feeding specialisation") +
  xlab("Year") + ylab("Feeding specialisation")



###########################################################
#######################  FECUNDITY  #######################
###########################################################

### Egg size
EggSize <- summarise_CWM(FD_list, 8, 100,110)
# plot egg size
ggplot(EggSize, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Egg Size") +
  xlab("Year") + ylab("Egg Size (mm2)")


### Egg load
EggLoad <- summarise_CWM(FD_list, 9, 100,110)
# plot egg size
ggplot(EggLoad, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Egg Load") +
  xlab("Year") + ylab("Egg Load")



###########################################################
#############  Thermal tolerance & phenology  #############
###########################################################

### Adult hardiness
AH <- summarise_CWM(FD_list, 10, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  AH[,i] <- as.numeric(as.character(AH[,i]))
}
# summarise mean, sd and sem
require(plotrix)
AH$mean <- apply(AH[,1:1000], 1, mean)
AH$sd <- apply(AH[,1:1000], 1, sd)
AH$sem <- apply(AH[,1:1000], 1, std.error)
# plot
ggplot(AH, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Adult hardiness") +
  xlab("Year") + ylab("Adult hardiness")

### Overwintering stage
HibStage <- summarise_CWM(FD_list, 11, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  HibStage[,i] <- as.numeric(as.character(HibStage[,i]))
}
# summarise mean, sd and sem
require(plotrix)
HibStage$mean <- apply(HibStage[,1:1000], 1, mean)
HibStage$sd <- apply(HibStage[,1:1000], 1, sd)
HibStage$sem <- apply(HibStage[,1:1000], 1, std.error)
# plot
ggplot(HibStage, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Overwintering stage") +
  xlab("Year") + ylab("Overwintering stage")


### Voltinism score
VoltScore <- summarise_CWM(FD_list, 12, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  VoltScore[,i] <- as.numeric(as.character(VoltScore[,i]))
}
# summarise mean, sd and sem
require(plotrix)
VoltScore$mean <- apply(VoltScore[,1:1000], 1, mean)
VoltScore$sd <- apply(VoltScore[,1:1000], 1, sd)
VoltScore$sem <- apply(VoltScore[,1:1000], 1, std.error)
# plot
ggplot(PopStr1t, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Voltinism score") +
  xlab("Year") + ylab("Voltinism score")

###########################################################
##################  Population structure  #################
###########################################################

### Population Structure score 
POPSTR2 <- summarise_CWM(FD_list, 13, 1000,110)

# Loop through and make all columns numeric
for(i in 1:1000){
  POPSTR2[,i] <- as.numeric(as.character(POPSTR2[,i]))
}
# summarise mean, sd and sem
require(plotrix)
POPSTR2$mean <- apply(POPSTR2[,1:100], 1, mean)
POPSTR2$sd <- apply(POPSTR2[,1:100], 1, sd)
POPSTR2$sem <- apply(POPSTR2[,1:100], 1, std.error)
# plot
ggplot(POPSTR2, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Population structure score") +
  xlab("Year") + ylab("Population structure score")

### Breeding population Structure 
PopStr1t <- summarise_CWM(FD_list, 14, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  PopStr1t[,i] <- as.numeric(as.character(PopStr1t[,i]))
}
# summarise mean, sd and sem
require(plotrix)
PopStr1t$mean <- apply(PopStr1t[,1:100], 1, mean)
PopStr1t$sd <- apply(PopStr1t[,1:100], 1, sd)
PopStr1t$sem <- apply(PopStr1t[,1:100], 1, std.error)
# plot
ggplot(PopStr1t, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Breeding population structure score") +
  xlab("Year") + ylab("Breeding population structure score")

### Metapopulation Structure
METApop <- summarise_CWM(FD_list, 15, 1000,110)
# Loop through and make all columns numeric
for(i in 1:1000){
  METApop[,i] <- as.numeric(as.character(METApop[,i]))
}
# summarise mean, sd and sem
require(plotrix)
METApop$mean <- apply(METApop[,1:1000], 1, mean)
METApop$sd <- apply(METApop[,1:1000], 1, sd)
METApop$sem <- apply(METApop[,1:1000], 1, std.error)
# plot
ggplot(METApop, aes(x=(year+1899), y=mean)) + 
geom_pointrange(aes(ymin=mean-sd, ymax=mean+sd)) + 
  ggtitle("Metapopulation structure score") +
  xlab("Year") + ylab("Metapopulation structure score")









str(FD_list[[10]])
```